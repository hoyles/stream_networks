# Modeling New Zealand eel populations the VAST stream network spatial model

## Installing and loading VAST

See `VAST` installation instructions available at {r} [on the VAST GitHub site] (https://github.com/James-Thorson/VAST#installation-instructions).

For now, use the version of VAST that includes New Zealand rock lobster as an example dataset:
```{r load, eval=FALSE}
devtools::install_github("merrillrudd/VAST")
```


## Data

Load the New Zealand longfin eel data file made available through VAST:
```{r load2, message=FALSE}
library(VAST)
data(NZ_longfin_eel, package="FishStatsUtils")
```

### Explore stream network data
There are `r nrow(NZ_longfin_eel)` observations in the dataset across `r length(unique(NZ_longfin_eel$year))` years and `r length(unique(NZ_longfin_eel$nzsegment))` segments.

For use in VAST, each segment is defined by a downstream parent node and an upstream child node, along with the distance between parent and child nodes and the latitude and longitude of each node. 

We used the heading `nz_tnode` as the parent node and `nz_fnode` as the child node to define each segment in the New Zealand dataset including presence/absence of longfin eels. 

```{r define_nodes}
## parent nodes - downstream
parents <- NZ_longfin_eel$nz_tnode

## child nodes - upstream
children <- NZ_longfin_eel$nz_fnode

## unique nodes
pnodes <- unique(parents) ## 7486 downstream parent nodes
cnodes <- unique(children) ## 8038 upstream child nodes
nodes <- unique(c(pnodes, cnodes)) ## 14338 unique nodes

## headwater nodes
hcnodes <- unique(NZ_longfin_eel$nz_fnode[which(NZ_longfin_eel$Headwater==1)])

## coastal nodes
rpnodes <- unique(NZ_longfin_eel$nz_tnode[which(NZ_longfin_eel$NextDownSeg==0)])
```

There are `r length(nodes)` unique nodes within the dataset, with `r length(cnodes)` unique upstream child nodes and `r length(pnodes)` unique downstream parent nodes.

`r round(100*length(unique(NZ_longfin_eel$nz_fnode[which(NZ_longfin_eel$Headwater==1)]))/length(cnodes))`% of upstream child nodes are headwater nodes, and `r round(100*length(unique(NZ_longfin_eel$nz_tnode[which(NZ_longfin_eel$NextDownSeg==0)]))/length(pnodes))`% of downstream parent nodes connect to the sea. `r round(100*length(unique(NZ_longfin_eel$nzsegment[which(NZ_longfin_eel$Headwater==1 & NZ_longfin_eel$NextDownSeg==0)]))/length(unique(NZ_longfin_eel$nzsegment)))`% of segments have a headwater upstream child node and parent node connecting to the sea, thus disconnected from other stream segments.

However, only `r pparent_also_child <- round(100*length(which(pnodes %in% cnodes == TRUE))/length(pnodes)); pparent_also_child`% of parent nodes are also child nodes. `r pcoast <- round(100*length(rpnodes)/length(pnodes)); pcoast`% of downstream parent nodes are along the coast, leaving `r 100-pcoast-pparent_also_child`% of downstream parent nodes disconnected inland. 

```{r plot_obs_prepare, include=FALSE}
library(dplyr)
loc <- NZ_longfin_eel %>% select('x','y.1')
loc2 <- unique(loc)
obs_per_loc <- lapply(1:nrow(loc2), function(i){
  sub <- NZ_longfin_eel[which(NZ_longfin_eel[,'x']==loc2[i,'x'] & NZ_longfin_eel[,'y.1']==loc2[i,'y.1']),]
  nobs <- nrow(sub)
  out <- t(rbind.data.frame(t(loc2[i,]), 'Nobs'=nobs))
  return(out)
})
obs_per_loc <- do.call(rbind, obs_per_loc)
df <- as.data.frame(obs_per_loc)
colnames(df) <- c("X", "Y", "Nobs")
```


```{r plot_obs, echo=FALSE, fig.cap="Downstream nodes of stream segments sampled across years, where `Nobs` is the number of years where each segment is sampled."}

library(ggplot2)
p <- ggplot(df) + geom_point(aes(x=X, y=Y, size=Nobs), alpha=0.1) + xlab("X coordinates") + ylab("Y coordinates") + theme_bw()
p
```

### Format data for VAST

First, VAST uses the node number as a pointer in a network grid that is defined by the number of nodes, and therefore the nodes must be re-cast to an index from 1 to length(unique(nodes)) instead of their raw node names (e.g. 12345, 305634). Therefore, we assigned each node to a number from 1 to length(unique(nodes)):
```{r index}
## change nodes (xxxx - xxxxx) to indexed nodes (1-length(nodes))
inodes <- seq_along(nodes)
ipnodes <- sapply(1:length(pnodes),function(x) inodes[which(nodes == pnodes[x])]) ## parents
icnodes <- sapply(1:length(cnodes),function(x) inodes[which(nodes == cnodes[x])]) ## children

## replace parent and child nodes with indexed nodes
parent_i <- sapply(1:nrow(NZ_longfin_eel), function(x){
	ipnodes[which(pnodes == NZ_longfin_eel$nz_tnode[x])]
})
child_i <- sapply(1:nrow(NZ_longfin_eel), function(x){
	icnodes[which(cnodes == NZ_longfin_eel$nz_fnode[x])]
})

## rename each obseveration to indexed nodes
NZ_longfin_eel$parent_i <- parent_i
NZ_longfin_eel$child_i <- child_i
```

### Format stream network

First we subset the total NZ_longfin_eel dataset with the columns we'll need for the analysis. This represents the information at all of the child nodes. 
```{r format_children}
## remove columns to be used in VAST
## i = number of observations
Network_iz_ll_1 <- NZ_longfin_eel %>% select(year, present, parent_i, child_i, Shape_length, lat, long)
colnames(Network_iz_ll_1) <- c("year", "present", "parent_i", "child_i", "dist_i", "lat", "long")
```

Next we need to define all of the parent nodes that are not otherwise defined as child nodes.
```{r format_parents}
## define parents that are not children
pindex <- which(Network_iz_ll_1$parent_i %in% Network_iz_ll_1$child_i == FALSE)
Network_iz_ll_2 <- data.frame("year"=Network_iz_ll_1[pindex,"year"],
					"present"=Network_iz_ll_1[pindex,"present"],
					"parent_i"=0, 
					"child_i"=Network_iz_ll_1[pindex,'parent_i'], 
					'dist_i'=Inf, 
					'lat'=Network_iz_ll_1[pindex,'lat'], 
					'long'=Network_iz_ll_1[pindex,'long'])

## all nodes defined for each observation
Network_iz_ll <- rbind(Network_iz_ll_1,  Network_iz_ll_2)
```

`Network_iz_ll` is a data frame where nodes are properly defined for each observation with latitude and longitude. However, the VAST stream network approach also requires a dataframe where all unique nodes are defined, which is used to set up the geographic network matrix.
```{r format_sz}
Network_sz <- unique(Network_iz_ll %>% select(c(parent_i, child_i, dist_i)))
colnames(Network_sz) <- c('parent_s','child_s','dist_s')
```

The latitude and longitude of each node should remain the same across observations at the node, but they vary slightly between observations. 
```{r check_ll}
Network_sz_ll <- unique(Network_iz_ll %>% select(c(parent_i, child_i, dist_i, lat, long)))
nrow(Network_sz_ll)
nrow(Network_sz)
```

For now I just use the latitude and longitude for a single observation for each segment.
```{r check_ll_parents}
Network_sz_ll2 <- lapply(1:nrow(Network_sz), function(x){
	sub <- Network_sz_ll[which(Network_sz_ll$parent_s == Network_sz$parent_s[x] & Network_sz_ll$child_s == Network_sz$child_s[x]),]
	out <- sub[1,]
	return(out)
})
Network_sz_ll2 <- do.call(rbind, Network_sz_ll2)
```

The unique combination of latitudes and longitudes is fewer than the number of nodes, which is at least due to the fact that the parent nodes disconnected to other downstream nodes share the same latitude and longitude of the child node for that segment. 
```{r lljitter}
ll <- Network_sz_ll2 %>% select('lat', 'long')
ll2 <- unique(ll)
Network_sz_ll3 <- lapply(1:nrow(ll2), function(x){
	sub <- Network_sz_ll2[which(Network_sz_ll2$lat==ll2[x,'lat'] & Network_sz_ll2$long==ll2[x,'long']),]
	out <- sub
	if(nrow(sub)>1){
		out$lat <- jitter(out$lat)
		out$long <- jitter(out$long)
	}
	return(out)
})
Network_sz_ll3 <- do.call(rbind, Network_sz_ll3)
```

## VAST model setup

# ```{r model_setup}
# Version = "VAST_v5_2_0" # SpatialDeltaGLMM::get_latest_version( package="VAST" )
# Method = "Stream_network"
# grid_size_km = 1
# n_x = nrow(Network_sz)  # Specify number of stations (a.k.a. "knots")
# 
# ## spatial intercept, keep "Omega2"=0 and "Epsilon2"=0 for presence/absence data
# FieldConfig = c("Omega1"=1, "Epsilon1"=0, "Omega2"=0, "Epsilon2"=0)
# OverdispersionConfig = c("Eta1"=0, "Eta2"=0)
# Options =  c("Calculate_Range"=0, "Calculate_effective_area"=0)
# RhoConfig = c("Beta1"=0, "Beta2"=3, "Epsilon1"=0, "Epsilon2"=0)
# 
# ## lognormally-distributed
# ObsModel = c("PosDist"=1, "Link"=0)
# 
# ## region and dataset
# Data_Set = "NZ_longfin_eel"
# Region = switch(Data_Set, "NZ_longfin_eel"="New_Zealand_streams")
# strata.limits <- data.frame('STRATA'="All_areas")
# 
# ## presence-absence observations
# b_i <- NZ_longfin_eel$present
# 
# ## add a small amount to presence observations
# set.seed(123)
# b_i_new <- b_i + rnorm(length(b_i), 0, 0.0001)
# b_i_new[which(b_i==0)] <- 0
# 
# ## setup geostatistical data
# ## observations
# Data_Geostat <- data.frame( "Catch_KG" = b_i_new, 
# 							"Year" = NZ_longfin_eel$year,
# 							 "Vessel" = "missing", 
# 							 "AreaSwept_km2" = NZ_longfin_eel$Shape_length, 
# 							 "Lat" = NZ_longfin_eel$lat, 
# 							 "Lon" = NZ_longfin_eel$long, 
# 							 "Pass" = 0)
# ## network - input grid latitude and longitude by node
# Extrapolation_List = FishStatsUtils::make_extrapolation_info( Region="User", 
# 									input_grid=cbind("Lat"=Network_sz_ll3$lat, 
# 													"Lon"=Network_sz_ll3$long, 
# 													"Area_km2"=Network_sz_ll3$dist_s), 
# 									strata.limits=strata.limits )
# ## change latitude and longitude by node, not using Kmeans
# Spatial_List = FishStatsUtils::make_spatial_info( n_x=n_x, 
# 												  Method=Method, 
# 												  Lon_i=Data_Geostat[,'Lon'], 
# 												  Lat_i=Data_Geostat[,'Lat'], 
# 												  "LAT_intensity"=Network_sz_ll3$lat, 
# 												  "LON_intensity"=Network_sz_ll3$long, 
# 												  Extrapolation_List=Extrapolation_List, 
# 												  DirPath=ModFile, 
# 												  Save_Results=TRUE )
# 
# ## number of knots now equal to number of nodes
# Data_Geostat = cbind( Data_Geostat, "knot_i"=Spatial_List$knot_i )
# 
# ## data file for TMB
# Data = Data_Fn("Version"=Version, 
# 				"FieldConfig"=FieldConfig, 
# 				"OverdispersionConfig"=OverdispersionConfig, 
# 				"RhoConfig"=RhoConfig, 
# 				"ObsModel"=ObsModel, 
# 				"c_iz"=rep(0,nrow(Data_Geostat)), 
# 				"b_i"=Data_Geostat[,'Catch_KG'], 
# 				"a_i"=Data_Geostat[,'AreaSwept_km2'], 
# 				"v_i"=as.numeric(Data_Geostat[,'Vessel'])-1, 
# 				"s_i"=Data_Geostat[,'knot_i']-1, 
# 				"t_iz"=Data_Geostat[,'Year'], 
# 				"a_xl"=Spatial_List$a_xl, 
# 				"MeshList"=Spatial_List$MeshList, 
# 				"GridList"=Spatial_List$GridList, 
# 				"Method"=Spatial_List$Method, 
# 				"Options"=Options, 
# 				"Network_sz"=Network_sz )
# 
# TmbList = Build_TMB_Fn("TmbData"=Data, 
# 						"RunDir"=ModFile, 
# 						"Version"=Version, 
# 						"RhoConfig"=RhoConfig, 
# 						"loc_x"=Spatial_List$loc_x, 
# 						"Method"=Method)
# 
# Obj = TmbList[["Obj"]]
# Opt = TMBhelper::Optimize( obj=Obj, lower=TmbList[["Lower"]], upper=TmbList[["Upper"]], getsd=TRUE, savedir=ModFile, bias.correct=TRUE, newtonsteps=3, bias.correct.control=list(sd=FALSE, split=NULL, nsplit=1, vars_to_correct="Index_cyl") )
# 
# Report = Obj$report()
# SaveResults = list("Opt"=Opt, "Report"=Report, "ParHat"=Obj$env$parList(Opt$par), "Data"=Data)

```


